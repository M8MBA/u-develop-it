Module 12 - SQL

Structured Query Language

Reference Guide
https://coding-boot-camp.github.io/full-stack/mysql/mysql-reference-guide

MySQL -  is considered the most reliable, scaleable, and developer-friendly open source relational database management system. It powers the back end of many of the popular social, streaming, and service web application

mySQL2 - is a MySQL client for Node.js with a focus on performance. This is the npm package you'll use to connect your Node.js applications to a MySQL database.

Which MySQL command do we use to display a table and information about each column's data types?

CRUD: creating, reading, updating, and deleting
    the four basic operations of most databases

Do not have to use all caps its a visual thing.
Makes the document easier to read.

VARCHAR - character limit

    A database is a collection of interrelated data. This data is stored in one or more tables that are related to one another.

    A table is composed of rows and columns. A column represents a field. A row represents a record.

    A query is a request for data from a database table or a combination of tables.

opening the MySQL Shell that connects the terminal to the MySQL instance. In the terminal, at the root directory of the project, enter the following command:

    mysql -u root -p

mysql> 

    This command helps verify that we're in the MySQL Shell. For an explanation of this command or to troubleshoot connection problems, refer to the Up and Running setup guide.

The MySQL Shell enables us to create and delete databases, tables, table records, and queries to MySQL.

Notice that the SQL keywords are in all caps. This SQL convention helps differentiate the SQL commands from identifiers like the database, table, and column names, which often appear in lowercase. Using all caps for SQL keywords is optional, but identifiers are case-sensitive, just like in JavaScript. For example, election and Election would reference different databases.

Also note that the command must be terminated by a semicolon (;). Otherwise, a new line will prompt you for the next command. Input ; to escape the prompt, so that you can enter the command from the previous line.

Now that the database has been created, we must select the election database so that any tables we create will be associated with that database. We'll do that by using the following command:

USE election;

-------------------------------------------------------

Creating the Table using MySQL CLI

We've decided to start with the candidates table, which will include first name, last name, and a Boolean value to track whether candidates are industry connected—an important consideration in the tech community.

The SQL statement to create a table is, appropriately, CREATE TABLE. It is followed by the specification for the table you want to create.

Take a look at the following SQL statement to create the candidates table:

CREATE TABLE candidates (
  id INTEGER AUTO_INCREMENT PRIMARY KEY,
  first_name VARCHAR(30) NOT NULL,
  last_name VARCHAR(30) NOT NULL,
  industry_connected BOOLEAN NOT NULL
);

Like JavaScript, SQL ignores white space and new lines, which means that clean formatting can improve readability. SQL also tends to be easily interpretable due to its use of plain language. With that in mind, let's review the preceding statement.

In the first line of the statement, we create a table called candidates. Next, a set of parentheses lists the details of each column, including name, data type, and other keywords.

The column names must not contain spaces and are normally lowercase. Notice that the statement names four columns, which are comma separated.

The data types follow the column names. VARCHAR is followed by parentheses and a number, whereas BOOLEAN and INTEGER aren't. Can you guess which data type VARCHAR represents?

If you guessed text, you're correct! VARCHAR stands for a variable character.

The number that follows VARCHAR represents the number of characters that this column's values can have. A BOOLEAN wouldn't need a size limit, and most numbers in common use are only so large, but a text field could be as long as a book. Because data storage can be expensive, it's important to limit the amount of space that each field uses, especially for huge tables.
connect the dots

We're already familiar with data types. In JavaScript, we determined the data type by declaring a variable and assigning a value to that variable. JavaScript is a dynamically typed language—the value determines the variable's data type. In SQL, when we plan to store a value in a column, we explicitly declare the data type and storage parameters. If anyone tries to store data outside those parameters (e.g., a string in an INTEGER column), the database will not allow it.
End of text box.

Unlike JavaScript, MySQL and some other relational databases store Boolean values as 0 for false and 1 for true. Some databases have convenient constants named FALSE and TRUE set to 0 and 1, respectively.

Now that we've determined the column names and their data types, let's explore the id column, along with PRIMARY KEY and AUTO_INCREMENT.

The other columns contain pertinent information about the candidates, including their names and whether they're connected to the industry. In contrast, the id field is primarily used internally in MySQL to identify records. Although an id column isn't required for every table, you'll need one in any table that contains unique records. In practice, most tables will have one.

The id is designated using the PRIMARY KEY and AUTO_INCREMENT attributes. PRIMARY KEY states that each value in this column must be unique for each record in the table. AUTO_INCREMENT, as you might guess, increments with each successive row and assigns that new value to the id. This keyword ensures that even if all other column values are identical for multiple records, the id will always be different—making the records distinguishable from each other.

Later, we'll use PRIMARY KEY to link tables together. Each table can only contain one column with the PRIMARY KEY designation.

The NOT NULL keyword means that a column must contain a value. In other words, if someone attempts to insert a record into candidates with any missing values, the database will not allow it because all columns are NOT NULL. (Conversely, NULL would mean that it's okay for a record to not have a value in a specific column.) Note that a PRIMARY KEY column by definition must contain a value, so it doesn't require the explicit NOT NULL keyword.

To verify that the table was created successfully, we can use the following MySQL CLI command:

        DESCRIBE candidates;

The WHERE clause is a powerful filtering tool that can be used with equality operators like less than (<) or not equal to (!=). We can also use the OR and AND logical operators to evaluate multiple conditions. If the expression evaluates to true, the row is returned.
https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html

***** important *****

    Use the command quit to exit the MySQL Shell. To find more commands available in the MySQL Shell, enter help.

Setup the node.js application with MySQL
    Initialize Node.js: npm init --y

Now that we've created package.json, be sure to create the .gitingore file with the node_modules/ entry, as shown in the following line of code, so that we don't needlessly track or push all the npm packages to GitHub:

    echo "node_modules/" > .gitignore

This creates the .gitignore file and wrote node_modules/ to the file.

Install npm packages

    npm install express mysql2

With this command, we've installed the express and mysql2 packages. We used the express package previously; now we'll use it to build the routes. The mysql2 package, which we haven't used before, will enable us to connect to the MySQL database and execute the SQL commands on the database.

Install and set up using Jest
    Let's also include the jest package so that we can test in the development phase. Let's place this package in devDependencies so that it's not included in the production environment. Use the following command for that:

        npm install jest --save-dev      

TESTS:
We should test them and verify their functionality.

To do this, let's change the current "test" script to the package.json file to the following:

"scripts": {
  "test": "jest"
},  

now run: npm test

We need to add one more script to start the Express.js server. Add the following code to the package.json file, under the test script:

"start": "node server.js"

You'll appreciate having a script for this command because an app's server must often be run many times due to changes in development!
------------------------------------------------

Check the database

    ensure that the database is set up and ready to go.

    Check that your MySQL Server is running(check system preferences)—initiate the MySQL command line by typing the following in your command line:

        mysql -u root -p
_________________________________________

Create Connection to Express.js Server

In the next step, you'll create a connection to the Express.js server to host the application. If you need a refresher on the purpose of these steps, please revisit the module on Express.js.

Follow these steps to create the connection:

    Create the server.js file in the root directory, using the following command at the command line:

    touch server.js

    Open the server.js file and import express at the top of the file, by adding the following code:

    const express = require('express');

    Add the PORT designation and the app expression, by adding the following code:

    const PORT = process.env.PORT || 3001;
    const app = express();

    Add the Express.js middleware, by adding the following code:

    // Express middleware
    app.use(express.urlencoded({ extended: false }));
    app.use(express.json());

    Now let's add the function that will start the Express.js server on port 3001. Place the following code at the bottom of the server.js file:

    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });

-----------------------------------------------

Test the Express.js Connection

And that's it! Let's see if the connection is working. Let's create a GET test route and place it above the connection function that we just created, as shown in the following example:

app.get('/', (req, res) => {
  res.json({
    message: 'Hello World'
  });
});

In the preceding statement, we chose the route method get() and the response method res.json() to send the response message "Hello World" back to the client.

At the terminal, execute the script we added to start the Express.js server, as follows:

npm start

We should see the following message logged in the terminal response:

Server running on port 3001

Let's open a browser and type the local host port connection into the address bar: http://localhost:3001 (Links to an external site.).

Awesome! You've confirmed a connection to the Express.js server.

Below the GET route, let's add a route to handle user requests that aren't supported by the app, as follows:

// Default response for any other request (Not Found)
app.use((req, res) => {
  res.status(404).end();
});

--------------------------------------------------

Connect to the MySQL Database

In this step, we'll connect to the MySQL database. To begin, we'll need to import the mysql2 package that we installed previously into the node_modules.

At the top of the file, insert the following statement:

const mysql = require('mysql2');

Now let's add the code that will connect the application to the MySQL database. Add the following expression under the Express.js middleware section in server.js, right after app.use(express.json());:

// Connect to database
const db = mysql.createConnection(
  {
    host: 'localhost',
    // Your MySQL username,
    user: 'root',
    // Your MySQL password
    password: '',
    database: 'election'
  },
  console.log('Connected to the election database.')
);

You'll need to replace the values of user and password with your MySQL username and password.

Save your work and restart the server once more. The following success message will appear in the terminal if the connection was made correctly:

Connected to the election database.
Server running on port 3001

Woo-hoo! We're connected to the database.

-------------------------------------------

Let's query the database to test the connection. In server.js, type the following statement above the catchall route(above the app.listen), to return all the data in the candidates table:

db.query(`SELECT * FROM candidates`, (err, rows) => {
  console.log(rows);
});

In the preceding statement, the db object is using the query() method. This method runs the SQL query and executes the callback with all the resulting rows that match the query.

Once this method executes the SQL command, the callback function captures the responses from the query in two variables: the err, which is the error response, and rows, which is the database query response. If there are no errors in the SQL query, the err value is null. This method is the key component that allows SQL commands to be written in a Node.js application.

Let's take a look at what the rows value returns on a successful query of the database. Save your work, then restart the server to see if these changes were effective.

-------------------------------------------

Create MySQL Queries for Read, Delete, and Create Operations

Create Query for Read Operation

    db.query(`SELECT * FROM candidates WHERE id = 1`, (err, row) => {
    if (err) {
        console.log(err);
    }
    console.log(row);
    });

Create Query for Delete Operation

    // Delete a candidate
    db.query(`DELETE FROM candidates WHERE id = ?`, 1, (err, result) => {
    if (err) {
        console.log(err);
    }
    console.log(result);
    });

        Notice a few marked differences in this statement:

    The DELETE statement has a question mark (?) that denotes a placeholder, making this a prepared statement. A prepared statement can execute the same SQL statements repeatedly using different values in place of the placeholder.

    An additional param argument following the prepared statement provides values to use in place of the prepared statement's placeholders. Here, we're hardcoding 1 temporarily to demonstrate how prepared statements work. So this would be the same as saying DELETE FROM candidates WHERE id = 1.

    As you'll see in the next query, if you need additional placeholders, the param argument can be an array that holds multiple values for the multiple placeholders.

    Result:
        Connected to the election database.
        Server running on port 3001
        ResultSetHeader {
        fieldCount: 0,
        affectedRows: 1,
        insertId: 0,
        info: '',
        serverStatus: 2,
        warningStatus: 0
        }

-------------------------------------------

Create Query for Create Operation

    Comment out the delete candidate statement and add the following new statement:

    // Create a candidate
    const sql = `INSERT INTO candidates (id, first_name, last_name, industry_connected) 
                VALUES (?,?,?,?)`;
    const params = [1, 'Ronald', 'Firbank', 1];

    db.query(sql, params, (err, result) => {
    if (err) {
        console.log(err);
    }
    console.log(result);
    });

    We made a few changes to this statement to account for the length of this SQL query. The SQL command and the SQL parameters were assigned to the sql and params variables respectively to improve the legibility for the call function to the database.

    In the SQL command we use the INSERT INTO command for the candidates table to add the values that are assigned to params. The four placeholders must match the four values in params, so we must use an array.

    Because the candidates table includes four columns—id, first_name, last_name, and industry_connected—we need four placeholders (?) for those four values. The values in the params array must match the order of those placeholders.